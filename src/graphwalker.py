#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# File              : graphwalker.py
# Author            : Wan Li
# Date              : 15.08.2019
# Last Modified Date: 15.08.2019
# Last Modified By  : Wan Li

import random

class GraphWalker(object):
    """
        Wraps a NetworkX graph and associates some random walk methods
    """
    def __init__(self, G, p, q):
        """
            Initializer
            Params:
                G: a NetworkX graph instance
                p: the return hyperparameter
                q: the inout hyperparameter
                The unnormalized walk probability is computed as follows:
                    W(preceding node's neigbors) = 1
                    W(preceding node) = 1/p
                    W(outward farther nodes) = 1/q
                (Reference: [Grover, Leskovec, KDD 2016])
        """
        self.G = G
        self.p = p
        self.q = q
        if p == 1 and q == 1:
            self.is_vanilla_deep_walk = True
        else:
            self.is_vanilla_deep_walk = False

        if self.is_vanilla_deep_walk == True:
            self.precompute_transition_probabilities()

    def precompute_transition_probabilities(self):
        """
            Precompute transition probabilities to reduce random walk overhead
        """
        pass

    def generate_one_walk(self, start_node, walk_len):
        """
            Generate one walk
        """
        walk = [start_node]
        while len(walk) < walk_len:
            cur_node = walk[-1]
            if self.is_vanilla_deep_walk == True:
                next_node = random.sample(list(self.G.neighbors(cur_node)), 1)[0]
                walk.append(next_node)
            else:
                pass
        return walk

    def simulate_walks(self, num_epochs, walk_len):
        """
            Generator of random walks
            Params:
                num_epochs: number of epochs for every node being the start node
                walk_len: length of each sequence generated by one random walk
        """
        all_nodes = list(self.G.nodes())
        for epoch in range(1, num_epochs + 1):
            print("epoch: {}/{}".format(epoch, num_epochs))
            random.shuffle(all_nodes)
            cnt = 0
            for node in all_nodes:
                yield self.generate_one_walk(node, walk_len)
                cnt += 1
                if cnt % 10000 == 0:
                    print(" processed: {}/{}".format(cnt, len(all_nodes)))
